Simple Java Code Generator ACL Based Deep Embedding ACL in Java Alessandro Coglio Kestrel Institute http   www kestrel edu AIJ  ACL In Java  deep embedding in Java executable  side effect free  non stobj  accessing subset ACL language without guards  ATJ  ACL Java  simple Java code generator turns ACL functions into AIJ representations are evaluated by AIJ interpreter  AIJ and ATJ enable possibly veri ed ACL code run as  and interoperate with  Java code  without much ACL framework Lisp runtime  current speed resulting Java code may adequate applications   Motivation and Contributions bene t writing code in theorem prover ability prove properties about it  such satis  faction requirements speci cations  facility generate code in one more programming languages from executable subset prover s logical language enables possibly veri ed code run as  and interoperate with  code written in those programming languages  Assuming correctness code generation  whose veri cation separable problem  akin compilation veri cation  properties proved about original code carry over generated code  ACL theorem provers s tight integration with underlying Lisp platform enables exe  cutable subset ACL logical language run readily and ef ciently Lisp  without need explicit code generation facilities  Nonetheless  situations may call running ACL code in programming languages  speci cally  when ACL code must interoperate with external code in those programming languages in more integrated and ef cient way than afforded by inter language commu  nication via foreign function interfaces       by inter process communication with ACL Lisp runtime via mechanisms like ACL Bridge     doc bridge   Using Lisp implementations written in target programming languages    involves not only porting ACL them  but also including much more runtime code than necessary target applications  Compilers from Lisp target programming languages may need changes wrappers  because executable ACL not quite subset Lisp  furthermore  ability compile non ACL Lisp code unnecessary complication far ACL compilation concerned  making potential veri cation harder  work described in paper contributes goal running ACL code in programming languages in integrated manner described above    ATJ  ACL Java  Java code generator ACL  ATJ translates executable  side effect  free  non stobj accessing ACL functions  without their guards  into Java  in simple way  by turning functions into deeply embedded Java representations are executed by ACL evaluator written in Java    AIJ  ACL In Java  deep embedding in Java executable  side effect free  non stobj  accessing subset ACL language without guards  AIJ consists  i  Java representation ACL values  terms  and environment   ii  Java implementation ACL primitive Shilpi Goel and Matt Kaufmann  Eds    ACL Theorem Prover and its Applications  ACL   EPTCS     pp     doi   EPTCS     Alessandro Coglio work licensed under Creative Commons Attribution License file ended 


 Java Code Generator and Deep Embedding functions  and  iii  ACL evaluator written in Java  AIJ executes deeply embedded Java representations ACL functions generated by ATJ  AIJ independent interest and can used without ATJ  ACL language subset supported by ATJ and AIJ includes values  primitive functions  and many functions with raw Lisp code see Section  details these two kinds functions  initial implementation AIJ favored assurance over ef ciency  quite simple  reduce chance errors and facilitate its potential veri cation  but also quite slow  careful introduction few optimizations  which not signi cantly complicate code but provide large speed ups  makes speed current implementation arguably adequate applications  see Section   Furthermore  code amenable additional planned optimizations  see Section    Background  Evaluation Semantics ACL ACL precisely de ned logical semantics     expressed in terms syntax  axioms  and inference rules  similarly logic textbooks and theorem provers  logical semantics applies logic  mode functions  not program mode functions  Guards are not part logic  but engender proof obligations in logic when guard veri cation attempted  ACL also documented evaluation semantics     doc evaluation   which could formal  ized in terms syntax  values  states  steps  errors  etc   customary programming languages  evaluation semantics applies logic mode and program mode functions  Guards affect evaluation semantics  based guard checking settings  Even non executable functions  e g  introduced via defchoose defun nx  degenerately evaluation semantics  because they yield error results when called  however  following discussion focuses executable functions  Most logic mode functions de nitions specify their logical and their evaluation se  mantics  former  de nitions are logically conservative axioms  latter  de nitions provide  instructions  evaluating calls function  de ned logic mode function  rela  tionship two semantics that  roughly speaking  evaluating call function yields  in  nite number steps  unique result value that  with argument values  satis es function s de ning axiom the actual relationship slightly more complicated  may involve guard checking  primitive functions     doc primitive  are in logic mode and no de nitions  they are built in  Examples are equal  if  cons  car  and binary    Their logical semantics speci ed by axioms ACL logic  Their evaluation semantics speci ed by raw Lisp code  under hood   relationship two semantics in paragraph  with slight complication pkg witness and pkg imports yield error results when called unknown package names  evaluation calls non strict  customary  Most program mode functions de nitions specify their evaluation semantics  similarly non primitive logic mode functions discussed above  Their de nitions specify no logical semantics  logic mode functions listed in global variable logic fns with raw code logical semantics speci ed by their ACL de nitions  but evaluation semantics speci ed by raw Lisp code   They are disjoint from primitive functions  which no de nitions   these functions  e g  len  raw Lisp code just makes them run faster but otherwise functionally equivalent ACL de nitions  Others side effects  carried out by their raw Lisp code but not re ected in their ACL de nitions  example  hard error prints message screen and immediately terminates execution  unwinding call stack  another example  fmt to comment window prints message screen  returning nil and continuing execution  But ACL de nitions these examplefile ended 


Alessandro Coglio  functions just return nil  program mode functions listed in global variable program fns with raw code evaluation semantics speci ed by raw Lisp code  Their ACL de nitions appear no actual use  Since stobjs     doc stobj  are destructively updated  functions manipulate stobjs may side effects well namely  destructive updates  Because single threadedness  these side effects are invisible in end to end input output evaluation these functions  however  they may visible in formulations evaluation semantics  such ones comprehend interrupts  which updating record  eld in place involves different steps than constructing new record value with changed  eld  built in state stobj     doc state   linked  external entities  e g   le system underlying machine  Thus  functions manipulate state may side effects these external entities  example  princ   a member logic fns with raw code  writes stream associated with output channel argument  and affects  le system  fact side effects evaluation semantics are not re ected in logical semantics design choice makes language more practical programming retaining ability prove theorems  But when generating Java code  these side effects should taken into consideration  instance  turning hard error and fmt to comment window into Java code returns  a representation of  nil  would incorrect least undesired  aside  similar issue applies use APT transformations     instance  using simplify transformation    turn calls hard error into nil  logically correct and within simplify s stipulations  may undesired unexpected   AIJ  Deep Embedding AIJ Java package whose public classes and methods provide API  i  build and unbuild represen  tations ACL values   ii  build representations ACL terms and ACL environment  and  iii  evaluate calls ACL primitive and de ned functions  without checking guards  By construction  ACL code represented and evaluated by AIJ executable  no side effects  not access stobjs  and no guards  AIJ consists few thousand lines Java code  including blank and comment lines   thoroughly documented with Javadoc comments  implementation takes advantage object oriented features like encapsulation  polymorphism  and dynamic dispatch  Java classes form AIJ are shown in simpli ed UML class diagram in Figure  and described in following subsections  Each class depicted box containing its name  Abstract classes italicized names  Public classes names preceded by    package private classes names preceded by    Inheritance   is a   relationships are indicated by lines with hollow triangular tips  Composition   part of   relationships are indicated by lines with solid rhomboidal tips  annotated with names containing class instances   elds store contained class instances  and with multiplicity contained instances each containing instance        means  zero more    When talking about AIJ  paper calls  build  and  unbuild  what often called  construct  and  destruct  in functional programming  because in object oriented programming latter terms may imply object allocation and deallocation  which not necessarily what AIJ API does  In AIJ s actual code  each class name pre xed with  Acl   e g  AclValue   external code can reference these classes unambiguously without AIJ s package name edu kestrel acl aij  paper omits pre x brevity  and uses fully quali ed names Java standard classes avoid ambiguities  e g  java lang String Java standard string class  distinguished from String in Figure  file ended 


 Java Code Generator and Deep Embedding Figure   Simpli ed UML class diagram AIJ  dashed boxes are just replicas avoid clutter  UML class diagram simpli ed because class boxes not contain  elds and methods    Values set values ACL evaluation semantics union sets depicted in Figure    i  integers  recognized by integerp   ii  ratios  i e  rationals are not integers  with no built in rec  ognizer   iii  complex rationals  recognized by complex rationalp   iv  characters  recognized by characterp   v  strings  recognized by stringp   vi  symbols  recognized by symbolp  and  vii  cons pairs  recognized by consp  Integers and ratios form rationals  recognized by rationalp  Ratio  nals and complex rationals form Gaussian rationals  which are numbers in ACL  recognized by acl numberp  logical semantics ACL allows additional values called  bad atoms   and consequently cons pairs may contain them directly indirectly  however  such values cannot constructed in evaluation  AIJ represents ACL values immutable objects Value and its subclasses in Figure   Each The term  ratio  used in Common Lisp speci cation    Section      This discussion not apply ACL r     Primitive  Environment  EvaluationExceptioncarnumeratordenominatorrealPartimaginaryPart  Character  Symbol  Cons  PackageName  String  Integer  Ratio  Rational  ComplexRational  Value  NumbercdrnamepackageNamenamevaluefunctionnameparametersargumentsbody        Term  Variable  Constant  FunctionApplication  Function  NamedFunction  LambdaExpressionValueSymbolfile ended 


Alessandro Coglio  Figure   Values ACL evaluation semantics  such class corresponds set in Figure   subset relationships in Figure  match inheritance relationships in Figure   sets values are unions sets values correspond abstract classes  sets correspond concrete classes  these classes are public  except package  private ones ratios and complex rationals  ratios and complex rationals are built indirectly via AIJ s API  by building rationals are not integers and numbers are not rationals  information about represented ACL values stored in  elds non abstract classes  Integer stores numeric value java math BigInteger  Ratio stores numerator and de  nominator Integers  in reduced form  i e  their greatest common divisor  and denominator greater than    ComplexRational stores real and imaginary parts Rationals  Character stores  bit code character char   String stores codes and order characters java lang String whose chars are   Symbol stores symbol s package name PackageName  a wrapper java lang String enforces ACL constraints package names  and symbol s name String  Cons stores component Values  these  elds are private  thus encapsulating internal representation choices and enabling their localized modi cation  ACL numbers  strings  and symbols no preset limits  but underlying Lisp runtime may run out memory  Their Java representations  e g  java math BigInteger  very large limits  whose exceedance could regarded running out memory  needed  Java representations could changed overcome current limits  e g  by using lists java math BigIntegers   public classes ACL values and package names provide public static factory methods build objects these classes  example  Character make char  returns Character with supplied argument code  throwing exception argument   another example  Cons make Value Value  returns Cons with supplied arguments components  classes provide overloaded variants  e g  Integer make int  and Integer make java math BigInteger   these classes provide no public Java constructors  thus encapsulating details object creation and re use  which essentially transparent external code because these objects are immutable  public classes ACL values provide public instance getter methods unbuild  i e  ex  tract information from  objects these classes  example  Character getJavaChar   returns code character char always   another example  Cons getCar   and Cons getCdr   return component Values cons pair  classes provide variants  e g  Integer getJavaInt    which throws exception integer not  t in int  and Integer getJavaBigInteger    characterscomplex rationalsratiosintegersstringssymbolscons pairsrationalsnumbersvaluesfile ended 


   Terms Java Code Generator and Deep Embedding ACL translates terms supplied by user  which may include macros and named constants  into restricted internal form  in which macros and named constants are expanded     doc term   In rest paper   term  means  translated term   i e  term in restricted internal form  set ACL terms consists  i  variables  which are symbols   ii  quoted constants  which are lists  quote value   where value value  and  iii  function applications  which are lists  fn arg     argn  where fn function and arg       argn are zero more terms  function fn used in term  i  named function  which symbol   ii  lambda expression  which list  lambda  var     varm  body   where var       varm are zero more symbols and body term  whose free variables are among var       varm  i e  lambda expressions are always closed   AIJ represents ACL terms in manner similar ACL values  immutable objects Term and its subclasses in Figure   functions are represented immutable objects Function and its subclasses in Figure   superclasses are abstract  subclasses are concrete  these classes are public  information about represented ACL terms stored in private  elds non abstract classes  Variable and NamedFunction are wrappers Symbol  Constant wrapper Value  FunctionApplication stores Function and array zero more Terms  LambdaExpression stores array zero more Variables and Term  non abstract classes ACL terms  and functions  provide public static factory methods build objects these classes  but no public Java constructors  similarly classes ACL values    Environment ACL terms are evaluated in environment includes function de nitions  package de nitions  etc  AIJ stores information about part environment in Environment in Figure   Since there just one environment time in ACL  class no instances and only static  elds and methods  ACL function de nition consists several pieces information  which AIJ only stores  i  name  which symbol   ii  parameters  which are zero more symbols  and  iii  body  which term  Environment stores function de nitions in private static  eld  java util Map from Symbols functions  names LambdaExpressions functions  parameters and bodies  public static method Environment addFunctionDef Symbol Symbol   Term  adds function de nition map  ACL package de nition associates list imported symbols package name  Environment stores package de nitions in private static  eld  java util Map from PackageNames packages  names java util Lists Symbols packages  import lists  public static method Environment addPackageDef PackageName List  adds package de nition map  AIJ uses  eld implement primitive function pkg imports  AIJ also uses information derived from  eld implement overloaded factory methods Symbol make build symbols  instance  Symbol make  ACL   CONS   returns Symbol with name  CONS  and package name  COMMON LISP   not package name  ACL   because  ACL  imports cons from  COMMON LISP   call Symbol make  ACL   CONS   Java equivalent ACL symbol notation acl  cons  Environment also stores value ACL constant  pkg witness name  in private static  eld  java lang String   eld may set  most once  otherwise exception thrown   These wrappers place Symbols and Values into class hierarchy Term and Function  given Java not support multiple class inheritance  instance  Symbol could not subclass Value and subclass Term file ended 


Alessandro Coglio  via public static method Environment setPackageWitnessName java lang String   AIJ uses  eld implement primitive function pkg witness    Primitive Functions Since ACL primitive functions no de nitions  AIJ cannot evaluate their calls via their bodies described in Section    AIJ implements these functions  natively  in Java  in package private class Primitive in Figure   Each primitive function except if  whose calls are evaluated non strictly described in Section    implemented by private static method Primitive execPrim  Value  Primitive execPrim  Value Value   based function s arity   where Prim Java  version  function s name  method returns Value  instance  Primitive execCharCode Value  implements char code  package private static method Primitive call Symbol Value    eval  uates call primitive function named by Symbol argument values in Value   argument  by calling appropriate Primitive execPrim method and returning result Value  Primitive no  elds and only static methods  no instances class are created  recognizers integerp  consp  etc  are implemented return Symbol t nil  based whether argument Value instance Integer  Cons  etc  destructors car  numerator  etc  are implemented return information from private  elds  constructors complex and cons are implemented via factory methods Number make and Cons make  constructor intern in package of symbol implemented via factory method Symbol make  and also calls getter method Symbol getPackageName second argument  conversions char code and code char are implemented by passing information from pri  vate  eld one class factory method class  conversion coerce slightly more laborious implementation  which scans builds Java representation ACL list  arithmetic operation unary   implemented via package private instance methods negate   in numeric classes  Primitive execUnaryMinus  when given x argument  calls x  negate    Dynamic dispatch selects negate method based runtime class x   Integer negate calls java math BigInteger negate its private  eld and uses result return negated Integer  Since   a b      a  b  Ratio negate calls Integer negate numerator  and uses re  sult return negated Ratio  Since   a   bi      a      b i  ComplexRational negate calls Rational negate real and imaginary parts  and uses returned Rationals return negated ComplexRational  each these two calls Rational negate is  in turn  dynamically dispatched Integer negate Ratio negate  based runtime classes real and imaginary parts  arithmetic operation binary   similarly implemented via package private instance methods add Value  in numeric classes  But presence second argument leads slightly more complicated interplay among methods  Primitive execBinaryPlus  when given x and y argu  ments  calls x  add y    dynamically dispatching based runtime class x   Integer add splits into two cases  y Integer  Integer sum returned using java math BigInteger add  otherwise  roles x and y are swapped  exploiting commutativity addition  by calling y  add x    which dynamically dispatches different add method  Ratio add performs analo  gous split  since a b   c d    ad   cb  bd  method calls multiply methods  further compli  cating method interplay  Since  a   bi     c   di     a   c     b   d i  ComplexRational add calls Rational add real and imaginary parts  which are further dynamically dispatched Integer add Ratio add  arithmetic operations unary   and binary   are implemented analogously unary   and binary    via reciprocate   and times Value  methods in numeric classes  Therefile ended 


 Java Code Generator and Deep Embedding additional interplay among methods  instance  since   a   bi     a  a   b      b  a   b  i  ComplexRational reciprocate calls arithmetic methods Rational  arithmetic comparison interface  In compareTo methods in numeric classes  when roles x and y are swapped in way in add methods described above  result negated before being returned  because comparison  unlike addition and multiplication  not commutative  equality equal implemented via methods equals java lang Object  in Value and its subclasses  which override java lang Object equals  These equality methods are implemented in obvious way  implementation bad atom  methods in Term and its subclasses  and  ii  apply Value    methods in Function and its subclasses  evaluation approach well known     eval methods take maps arguments bind values variable symbols  and return Value results  Constant eval returns constant s value  ignoring map  Variable eval returns value bound variable  throwing exception variable unbound  Application eval recursively evaluates argument terms and then calls Function apply function and resulting values  However  function represents if  Application eval  rst evaluates just  rst argument  and then  based result  either second third argument  consistently with non strictness if  apply methods take arrays zero more Values arguments  and return Value results  LambdaExpression apply evaluates lambda expression s body with freshly created map binds values parameters no old bindings are needed  because lambda expressions are closed  NamedFunction apply calls public method Environment call Symbol Value    with name function and argument values  Environment call operates follows  symbol names primitive function  forwarded  with values  Primitive call  symbol names function de ned in environment  lambda expression de nes function applied values  symbol not name primitive de ned function  exception thrown  AIJ evaluates ACL terms in purely functional way  without side effects  AIJ not check guards primitive de ned functions  aforementioned method Environment call calls ACL functions values only  not  names of  stobjs    Usage AIJ designed used follows by Java code outside AIJ s package  Aside from exhausting available memory  which is  unavoidably  always possibility file ended 


Alessandro Coglio    De ne ACL packages interest by repeatedly calling Environment addPackageDef  each package  use factory methods PackageName and Symbol build name and imported symbols  De ne built in and user de ned packages  in order in which they appear in ACL history  order ensures Symbol make not throw exception due unknown package    De ne ACL functions interest by repeatedly calling Environment addFunctionDef  each function  use factory methods value and term classes build name  parameters  and body  functions can de ned in order  long packages are de ned before functions  see step above     Call Environment setPackageWitnessName with appropriate value from ACL con  stant  pkg witness name     Call ACL primitive de ned function follows   a  Build name ACL function call  well zero more ACL values pass arguments  via factory methods value classes   b  Call Environment call with Symbol names function and Value array arguments   c  Unbuild returned Value needed inspect and use it  using getter methods value classes    Go back step  many times needed  protocol explains AIJ provides public API unbuilding ACL values but no public API unbuild ACL entities  terms etc    latter are built entirely by Java code outside AIJ s package  which therefore no need unbuild entities builds  Values  instead  may built by executing ACL code returns them results  Java code outside AIJ s package may need unbuild returned values inspect and use them  Besides structural constraints implicit in Java classes  and existence referenced packages when building symbols  necessary resolve imported symbols   AIJ not enforce well formedness constraints when building terms and entities  e g  constraint number arguments in function call matches function s arity  However  during evaluation  AIJ makes no well formedness assumptions and performs necessary checks  throwing informative exceptions these checks fail   ATJ  Code Generator ATJ ACL tool provides event macro generate Java code from speci ed ACL functions  generated Java code provides public API  i  build AIJ representation ACL functions and parts ACL environment and  ii  evaluate calls functions ACL values via AIJ  Java code generated by ATJ automates steps     and  in Section   and provides light wrapper step b  steps a and c must still performed directly via AIJ s API  ATJ consists few thousand lines ACL code  including blank lines  implementation level documentation  and comments   accompanied by few hundred lines user level documentation in XDOC  implementation thoroughly documented in XDOC well    Overview ATJ generates single Java  le containing single class  with following structure file ended 


 Java Code Generator and Deep Embedding package pname      specified by user import edu kestrel acl aij       AIJ classes import        few classes Java standard library public class cname       ACL  not specified by user    field record ACL environment been built not  private static boolean initialized   false     one method like each known ACL package  private static void addPackageDef hex              one method like each specified ACL function  private static void addFunctionDef hex  hex              API method build ACL environment  public static void initialize          API method evaluate ACL function calls  public static Value call Symbol function  Value   arguments         le name class   over written in current working directory  unless user speci es directory  ATJ directly generates Java concrete syntax  via formatted printing ACL output channel associated  le  without going through Java abstract syntax and pretty printer    Value and Term Building part building AIJ representation ACL environment  Java code generated by ATJ builds AIJ representations ACL values and terms  function de nitions include terms bodies  and constant terms include values  via factory methods discussed in Sections   and    In principle  ATJ could turn each ACL value term into single Java expression with  isomor  phic  structure  example  ACL value        A     x   could built follows  Cons make Cons make Integer make    Character make     String make  x    However  values and terms even modest size  e g  function bodies  would lead large expressions  which are not common in Java  Thus  ATJ breaks them into sub expressions assigned local variables  instance  example value built follows     statements  Value value   Integer make    Value value   Character make    Value value   Cons make value  value   Value value   String make  x       expression  Cons make value  value  In general  ATJ turns each ACL value term into  i  zero more Java statements incremen  tally build parts and  ii  one Java expression builds whole from parts  ATJ recursively  expression sub value sub term assigned new local variable used in expression containing super value super term  top level expressions are used explained in Sections   and   file ended 


Alessandro Coglio  generate new local variable names  ATJ keeps track three numeric indices  for values  terms  and lambda expressions recall latter are mutually recursive with terms  recursively tra  verses values and terms  appropriate index appended  value    term    lambda  and then incremented    Package De nition Building Java code generated by ATJ builds AIJ de nition each ACL package known when ATJ invoked  names known packages are keys alist returned by built in function known package alist  in reverse chronological order  AIJ de nition each these packages built by method addPackageDef hex  see Sec  tion     where hex even length sequence hexadecimal digits ASCII codes characters form package name  instance  de nition  ACL  package built by addPackageDef C  simple naming scheme ensures generated method names are distinct and valid  since ACL package names allow characters disallowed by Java method names  Each addPackageDef hex method builds Java list symbols imported by package  which ATJ obtains via pkg imports  Then method calls Environment addPackageDef with PackageName and list Symbols    Function De nition Building Java code generated by ATJ builds AIJ de nition each  non primitive  ACL function speci ed via one more function symbols fn       fn p supplied ATJ  Each fni implicitly speci es not only fni itself  but also functions called directly indirectly by fni  ensuring  closure  generated Java code under ACL calls  ATJ uses worklist algorithm  initialized with  fn     fn p   calculate list their closure under calls  Each iteration removes  rst function fn from worklist  adds result list  and extends worklist with functions directly called by fn are not already in result list   directly called by  means  occurring in unnormalized body property of   occurrences in guard fn not count  because ATJ  like AIJ  ignores guards  fn no unnormalized body property  must primitive  otherwise ATJ stops with error this happens fn constrained  not de ned  function  fn in logic fns with raw code program fns with raw code  see Section    must in whitelist functions are known no side effects  fn input output stobjs  ATJ stops with error this may only happen fn not primitive  AIJ de nition each these functions built by method addFunctionDef hex  hex  see Section     where hex and hex are even length sequences hexadecimal digits ASCII codes package and symbol names function symbol  instance  de nition len function built by addFunctionDef C CE  simple naming scheme ensures generated method names are distinct and valid  since ACL package and symbol names allow characters disallowed by Java method names  Each addFunctionDef hex  hex method  rst builds Term from unnormalized body property function  explained in Section    Then top level Java expression  along with Symbol function name and with Variable array function parameters  passed Environment addFunctionDef  This whitelist currently subset logic fns with raw code  consists functions whose raw Lisp code makes them run faster but otherwise functionally equivalent ACL de nitions file ended 


 Java Code Generator and Deep Embedding   Environment Building initialize method generated by ATJ  see Section    calls addPackageDef hex and addFunctionDef hex  hex methods described in Sections   and    method also calls Environment setPackageWitnessName with argument derived from  pkg witness name   package de nition methods are called in order in which corresponding packages are de ned  which reverse order alist returned by known package alist  ensures success calls Symbol make build elements package s im  port list  instance   P  imports q  sym  then  Q  must already de ned when  P  being de ned  is  addPackageDef  must already been called when addPackageDef  calls Symbol make  Q   SYM   part building  P  s import list  which needed de ne  P   other  wise  Symbol make  Q   SYM   would throw exception due  Q  being still unde ned  function de nition methods are called after package de nition methods  again ensure success Symbol make calls  relative order function de nitions unimportant  result list returned by ATJ s worklist algorithm  see Section    in no particular order  initialize method may called once by external code  method throws exception unless initialized  eld  see Section    false  and sets  eld true just before returning    Call Forwarding cname  call method generated by ATJ  see Section    forwards function name and ar  gument values Environment call  after ensuring initialized  eld true  i e  ACL environment been built  throws exception initialized still false   Preliminary Tests and Optimizations initial version AIJ deliberately written in very simple way  without regard performance  sort  executable speci cation  in Java  reasons increase assurance by reducing chance errors  facilitate potential veri cation code  avoid premature optimizations  and observe impact gradually introduced optimizations  Performance been tested mainly three example programs   rst ACL function computes factorial non tail recursively  second ACL function computes Fibonacci non tail recursively  third slightly modi ed version veri ed ABNF grammar parser    from ACL Community Books     doc abnf  grammar parser   parser  in  logic part mbe  calls nat list fix its input list natural numbers just before reading each natural number  which makes execution  in logic   which how AIJ executes  unduly slow  testing AIJ more realistically  parser tweaked avoid these calls nat list fix  tweaked parser about   lines  including blank lines   including theorems prove its termination in logic mode  and including return type theorems prove its guards  parser not only recognizes ABNF grammars  but also returns parse trees  Unsurprisingly  initial version AIJ quite slow  re examination code from performance perspective readily revealed several easy optimization opportunities  which carried out and are part current version AIJ  These are main ones  in order  Initially  tests conducted simpli ed version parser only recognized ABNF grammars  because ATJ not support mbe  which used in construction parse trees  de ned via  xtypes     doc fty    After extending ATJ support mbe  testing switched more realistic version parser also returns parse trees file ended 


Alessandro Coglio    Character array representation Strings replaced with java lang String    Symbols frequently used during evaluation  such ones t  nil  and names primitive functions  cached constants instead being built repeatedly    Characters interned  follows  Character objects  codes pre created and stored into array  in order their codes  factory method Character make char  indexes array with input code and returns corresponding object  Since ensures there just one object each character code  Character equals uses pointer equality  i e      and default fast java lang Object hashCode inherited    PackageNames  Strings  and Symbols interned  similarly Characters  follows  Since there potentially in nite number them  they are are created demand  each these three classes  objects created thus far are stored values java util Map  whose keys are java lang Strings PackageName and String  and PackageNames paired with Strings Symbol the pairing realized via nested maps  Each factory method  rst consults appropriate map  either returning existing object  creating new one added map  Similarly Character s interning  interning these classes enables use pointer equality in equality methods and inheritance default fast hash code method  Thanks AIJ s object oriented encapsulation  these optimizations easy and localized  These optimizations not involve ATJ  because code generated by ATJ essentially used just initialize ACL environment  see Section     which happens quickly factorial and Fibonacci functions and ABNF parser  Based few time measurements ABNF parser and few arti cial programs  optimizations reduced execution time  very roughly  by following factors  one after other   optimization     optimization    and  optimizations   and   all combined    Tables     and  report more systematic time measurements factorial function  Fibonacci function  and ABNF parser  Each row corresponds input program  natural numbers factorial and Fibonacci functions  ABNF grammars  all from Internet standards  including ABNF itself  ABNF parser   ACL  columns are execution in ACL  with guard checking   g c    set t  i e  typical execution  and  none  i e  execution  in logic   latter matches AIJ s execution   AIJ  column execution with AIJ s current version  Each cell contains minimum  average  and maximum real times from  runs  in seconds rounded millisecond  ACL times measured difference results read run time just before and just after call factorial function  Fibonacci function  top level ABNF parsing function  Java times measured difference results java lang System currentTimeMillis   just before and just after call cname  call corresponding ACL function  Given AIJ evaluator s recursive implementation  larger stack size than default must passed JVM   GB these time measurements  avoid stack over ow  times in Table  are roughly comparable each input  with ACL faster smaller inputs and AIJ faster larger inputs  presumably  most time spent multiplying large numbers  which happens in java math BigInteger in Java code and in Lisp s bignum implementation in ACL code  dwar ng contributions ACL and AIJ proper  especially larger inputs  times in Table  differ  looking averages  AIJ about   times slower than ACL with guard checking  none  which about   times slower than ACL with guard checking t  times in Table  differ well  looking averages  AIJ about   times slower than ACL with guard checking  none  which about   times slower than ACL with guard checking t  nonetheless  Even initial  unoptimized version AIJ took comparable times file ended 


 Java Code Generator and Deep Embedding absolute times suggest Java code parser usable  Performance needs vary  AIJ s current speed may adequate applications  such security critical interactive applications like cryptocurrency wallets  Furthermore  discussed in Section   there are more opportunities optimize AIJ  Input           ACL  g c  t  min           avg           max           ACL  g c   none  min max                     avg           min           AIJ avg           max           Table   Time measurements factorial function  Input     ACL  g c  t  min         avg         max         ACL  g c   none  min max                 avg         min         AIJ avg         max         Table   Time measurements Fibonacci function  Input ABNF grammar JSON grammar URI grammar HTTP grammar IMF grammar SMTP grammar IMAP grammar ACL  g c  t  min               avg               max               ACL  g c   none  max min                             avg               min               AIJ avg               max               Table   Time measurements ABNF parser  time measurements taken MacBook Pro   inch    with   GHz Intel Core i and  GB  MHz LPDDR  running macOS High Sierra Version     ACL times measured with commit eeacadeacbceefaccafe from GitHub running  bit Clozure Common Lisp Version     Java times measured with version AIJ in commit from GitHub above  running Oracle s  bit Java      Java SE Runtime Environment    build     Just before taking measurements  machine rebooted and only necessary applications started  performance ATJ not affect performance Java code  ATJ runs in   seconds each factorial function  Fibonacci function  and ABNF parser  including time write Java  les  measured by wrapping calls ATJ with time   As another data point  simpli ed parser mentioned in Footnote  about   times faster than current parser file ended 


Alessandro Coglio  Future Work  Evaluating non executable functions  i e  non primitive and without unnormalized body property   by throwing exception mirrors error ACL yields  easy but not necessarily useful  planned extension support guards and evaluation with different guard checking settings  in way ACL  Support functions with side effects will added one time  by writing native Java implementations  as done primitive functions  suitably mirror ACL side effects in Java  instance  hard errors could implemented exceptions  User de ned stobjs could supported by storing their contents in Java  elds are destructively updated  since state  linked  external entities  e g   le system   support built in stobj will involve use Java API those entities  Supporting stobjs also involves extending AIJ s public API call ACL functions stobj names  besides values  Direct support calling macros directly  and supplying named constants function calls  are also candidate extensions  generated method cname  call described in Section   not provide much beyond calling Environment call directly  but suggestive additional functionality  example  future versions cname could provide public method each top level target function fni supplied ATJ  with no parameter function name  and with many Value parameters function s arity instead single Value array parameter  another example  cname could provide additional public methods call each fni objects more speci c types  e g  Integer instead Value   based guards  names these methods should derived from names corresponding functions  according safe but more readable schemes than one described in Section   in fact  more readable scheme should used methods described in Section   and Section   well  reviewer suggested make  elds and methods Environment non static and multiple instances class once  worth exploring  There are more optimization opportunities beyond ones already carried out and described in Section   example  now each variable evaluation looks up variable symbol in hash map stores current binding values variables  another example  now each function call  rst looks up function symbol in hash map stores function de nitions in environment  and then  no de nition found  compares function symbol with primitive function symbols match found  Replacing enhancing AIJ s representation variable and function symbols with numeric indices should make these accesses much faster  third example  AIJ s evaluator could re implemented loop with explicit stack  instead recursion  fourth example  many built in ACL functions could implemented natively in Java  as done primitive functions   instead being interpreted  reviewer suggested implement hons     doc hons and memoization  in AIJ  and use instead cons  amounts interning Java objects represent ACL values  not just Characters  Strings  and Symbols see Section    enabling fast equality tests and hash code compu  tations  which could increase performance in applications  Perhaps future versions AIJ and ATJ could provide options use hons vs  cons  eventual path fast execution avoid interpretation overhead  by having ATJ turn ACL functions into shallowly embedded Java representations  customary in code generators  shal  If support evaluating non executable function added  ATJ should still include option signal error when worklist algorithm reaches non executable function  A preliminary experiment with just variable indices seems reduce execution times roughly by   Besides more conventional translation approaches  more speculative idea generate shallowly embedded repre  sentations by partially evaluating    AIJ interpreter deeply embedded representations generated by ATJ file ended 


 Java Code Generator and Deep Embedding low embedding will consist Java methods implement ACL functions  with suitably matching signatures  AIJ s representation and operations ACL values will still used  but AIJ s represen  tation and evaluator ACL terms will not  Under certain conditions  should possible generate variants these Java methods use more ef cient representations and operations  e g  Java int values and integer operations when there provably no wrap around  in particular leveraging ACL s forms and associated guard veri cation  which similarly help Lisp compiler  Given gen  erating these shallowly embedded representations inevitably more complicated and thus error prone  slower but safer interpreted evaluation could still available option  least in absence veri cation  Java code generated by ATJ can called by external Java code  but not vice versa  Allowing call direction may involve suitable ACL stubs correspond external code called  implementation ATJ could simpli ed by directly generating Java abstract syntax and using separable pretty printer write abstract syntax  le  More ambitious projects are  i  verify correctness AIJ s evaluator and primitive function implementations  and  ii  extend ATJ generate proof correctness generated Java code  like verifying compiler  Optimizing AIJ and generating shallowly embedded representations in ATJ make these veri cation tasks harder  idea worth exploring perform compositional veri cation optimized Java code against unoptimized Java code and latter against ACL code  approach generate Java code described in paper  including envisioned extensions described in section  could used generate code in programming languages  In particular  UML class diagram in Figure  could used object oriented programming languages   Related Work author not aware Java code generator ACL  Several theorem provers  Isabelle  PVS  Coq  etc   include facilities generate code in various programming languages  Standard ML  Ocaml  Haskell  Scala  C  Scheme  etc           These code generators use shallow embedding approaches  very different from ATJ and AIJ s deep embedding approach  These code generators may more relevant future versions ATJ and AIJ use shallow embedding approach  see Section    However  ACL language quite different from languages those provers   rst order vs  higher order  untyped with  xed universe  evaluation  values vs  typed with user de nable types  extra logical guards vs  types are part logic  and on  Thus  only ideas from those provers  code generators may relevant ACL  discussed in Section   there are ways ACL code interoperate with code in pro  gramming languages  without need generating code in those programming languages from ACL  However  obviated need should balanced against issues with these approaches discussed in Section   different approaches may best suited different applications  Acknowledgements work supported by DARPA under Contract No  FA  C   Thanks Matt Kaufmann useful discussions about ACL evaluation semantics  Thanks anonymous reviewers valuable suggestions file ended 


Alessandro Coglio References     Armed Bear Common Lisp  ABCL   https   abcl org     ACL Theorem Prover and Community Books  User Manual  http   www cs utexas edu  moore  acl manuals current manual     APT  Automated Program Transformations   http   www kestrel edu home projects apt     CFFI  Common Foreign Function Interface  https   common lisp net project cffi     Alessandro Coglio     Formalization ABNF Notation and Veri ed Parser ABNF Grammars  In  Proc  th Working Conference Veri ed Software  Theories  Tools  and Experiments  VSTTE   appear in Springer LNCS     Alessandro Coglio  Matt Kaufmann   Eric Smith     Versatile  Sound Tool Simplifying De nitions  In  Proc  th International Workshop ACL Theorem Prover and Its Applications  ACL    pp     doi   EPTCS       Coq    Reference Manual  https   coq inria fr     Florian Haftmann with contributions from Lukas Bulwahn     Code generation from Isabelle HOL the  ories  https   isabelle in tum de  Tutorial distributed with Isabelle HOL     Java Native Interface JNI Speci cation  https   docs oracle com javase  docs specs jni     Neil D  Jones  Carsten K  Gomard   Peter Sestoft     Partial Evaluation and Automatic Program Gen  eration  Prentice Hall  http   www itu dk people sestoft pebook     Matt Kaufmann   J Strother Moore     Precise Description ACL Logic  Technical Report  Department Computer Sciences  University Texas Austin  http   www cs utexas edu users  moore publications kma pdf     John McCarthy     Recursive Functions Symbolic Expressions and Their Computation by Machine  Part I  Communications ACM     pp     doi         Nararajan Shankar     Brief Introduction PVSC Code Generator  Automated Formal Methods  AFM    In  Proc  Workshop    Guy L  Steele     Common Lisp Language  Digital Press  https   www cs cmu edu Groups  AI html cltl cltl html file ended 


